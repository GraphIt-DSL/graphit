#ifndef VERTEX_SUBSET_H
#define VERTEX_SUBSET_H

//*****VERTEX OBJECT*****
struct vertexSubset {
  long n, m;
  uintE* s;
  bool* d;
  bool isDense;

  // make a singleton vertex in range of n
  vertexSubset(long _n, intE v)
    : n(_n), m(1), d(NULL), isDense(0) {
    s = newA(uintE,1);
    s[0] = v;
  }

  //empty vertex set
  vertexSubset(long _n) : n(_n), m(0), d(NULL), s(NULL), isDense(0) {}
  // make vertexSubset from array of vertex indices
  // n is range, and m is size of array
  vertexSubset(long _n, long _m, uintE* indices)
    : n(_n), m(_m), s(indices), d(NULL), isDense(0) {}
  // make vertexSubset from boolean array, where n is range
  vertexSubset(long _n, bool* bits)
    : n(_n), d(bits), s(NULL), isDense(1)  {
    m = sequence::sum(bits,_n); }
  // make vertexSubset from boolean array giving number of true values
  vertexSubset(long _n, long _m, bool* bits)
    : n(_n), m(_m), s(NULL), d(bits), isDense(1)  {}

  // delete the contents
  void del(){
    if (d != NULL) free(d);
    if (s != NULL) free(s);
  }
  long numRows() { return n; }
  long numNonzeros() { return m; }
  bool isEmpty() { return m==0; }

  // converts to dense but keeps sparse representation if there
  void toDense() {
    if (d == NULL) {
      d = newA(bool,n);
      ligra::parallel_for((long)0, (long)n, [&] (long i) { d[i] = 0; });
      ligra::parallel_for((long)0, (long)m, [&] (long i) { d[s[i]] = 1; });
    }
    isDense = true;
  }

  // converts to sparse but keeps dense representation if there
  void toSparse() {
    if (s == NULL) {
      _seq<uintE> R = sequence::packIndex<uintE>(d,n);
      if (m != R.n) {
        cout << "bad stored value of m" << endl;
        abort();
      }
      s = R.A;
    }
    isDense = false;
  }
  // check for equality
  bool eq (vertexSubset& b) {
    toDense();
    b.toDense();
    bool* c = newA(bool,n);
    ligra::parallel_for((long)0, (long)b.n, [&] (long i) {
        c[i] = (d[i] != b.d[i]);
      });
    bool equal = (sequence::sum(c,n) == 0);
    free(c);
    return equal;
  }

  void print() {
    if (isDense) {
      cout << "D:";
      for (long i=0;i<n;i++) if (d[i]) cout << i << " ";
      cout << endl;
    } else {
      cout << "S:";
      for (long i=0; i<m; i++) cout << s[i] << " ";
      cout << endl;
    }
  }
};

#endif
